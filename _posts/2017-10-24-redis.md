# redis命令
* redis支持在配置文件中, 将命令重新命名; 如下例:

```
//如将FLUSHALL 命名为复杂的名字保证只有自己的应用可以使用该命令
rename-command FLUSHALL oiupyhdggah12uit
//禁止某个命令可以直接设置为空字符串
rename-command FLUSHALL ""
```
# redis通信协议
* Redis通信协议是Redis客户端和Redis之间交流的语言, 通信协议规定了命令和返回值的格式, Redis支持两种通信协议:

    * 二进制安全的统一请求协议(unified request protocol);

    ```
    //SET foo bar的统一请求协议
    *3\r\n$3\r\nSET\r\n$3\r\nfoo\r\n$3\r\nbar\r\n
    ```
    * 比较直观的便于在telnet程序中输入的简单协议;

    这两种协议只是命令的格式有区别, 命令的返回值的格式是一样的;

# redis的管理
## redis-cli相关管理命令
### 查看耗时命令日志
* 每一条命令执行时间超过限制时候, redis就会将命令的执行时间等信息加入耗时命令日志中供开发查看;
* 该限制由配置文件中**slowlog-log-slower-than**配置项控制(默认是10000微妙 1000 000微妙=1秒);
* 如果设置**slowlog-log-slower-than**设置为负数, 表示关闭耗时命令日志;
* 耗时命令的日志存储在内存中, 可以通过配置文件中**slowlog-max-len**配置项来限制记录的条数(默认=128);
* 命令输出格式:
    * 日志唯一的ID;
    * 命令执行的Unix时间;
    * 消耗时间单位微妙;
    * 命令以及其参数;
```
192.168.154.128:6379[1]> slowlog get
 1) 1) (integer) 37
    2) (integer) 1508832190
    3) (integer) 13
    4) 1) "zrange"
       2) "myzset"
       3) "0"
       4) "2"
       5) "withscores"
    5) "192.168.154.128:43254"
    6) ""
 2) 1) (integer) 35
    2) (integer) 1508832165
    3) (integer) 4
    4) 1) "ZCARD"
       2) "myzset"
    5) "192.168.154.1:54125"
    6) ""
```

### 命令监控
redis提供了命令**MONITOR**命令来监控redis执行的所有命令; 在一个redis-cli输入命令: **MONITOR**, 然后打开另一个redis-cli执行命令, 查看监控输出:

```
192.168.154.128:6379[1]> monitor
OK
1508833404.033522 [0 192.168.154.128:43256] "select" "1"
1508833424.665236 [1 192.168.154.128:43256] "set" "foo" "bar1"
1508833430.233119 [1 192.168.154.128:43256] "set" "foo1" "bar2"
```
注: **MONITOR**非常的影响redis的性能, 一个客户端使用该命令, 会降低一半的负载能力; 所以该命令只适用于调试和纠错;

# redis空间优化

## 1. 精简键名和键值

精简键名和键值是最直观的减少内存占用的方式;  但是要把握好度, 不要单纯为了节省空间而使用不容易理解的键名;

## 2. 内部编码
很多时候单靠精简键名和键值所减少的空间远远不够, 还需要根据redis内部编码规则来节省更多的空间, redis为每一种数据类型提供了至少两种编码方式:


数据类型 | 内部编码 | OBJECT ENCODING命令结果 |
---|---|---|
字符类型 | REDIS_ENCODING_RAW, REDIS_ENCODING_INT, REDIS_ENCODING_EMBSTR | "raw", "int", "embstr"
列表类型 | REDIS_ENCODING_LINKEDLIST, REDIS_ENCODING_ZIPLIST | "linkedlist", "ziplist"
散列类型 | REDIS_ENCODING_HT, REDIS_ENCODING_ZIPLIST | "hashtable", "ziplist"
集合类型 | REDIS_ENCODING_HT, REDIS_ENCODING_INTSET | "hashtable", "intset"
有序集合类型 | REDIS_ENCODING_SKIPLIST,  REDIS_ENCODING_ZIPLIST | "skiplist", "ziplist"


### 说明

* 如果想要查看一个键的内部编码方式, 可以使用命令 **OBJECT ENCODING key**;
* 以散列类型为例, 一般散列类型是以散列表实现的, 这样可以实现O(1)复杂度的查找和赋值; 但是让元素较少的时候O(1)和O(n)的区别并不是特别大, 这时候redis会自动采用一种更加紧凑但是性能可能差一点的编码方式; 当内部元素增加, redis又会自动调整为散列表;
* redis的每一个键值都一个redisObject机构体保存;

```c++
typedef struct redisObject
{
    // 类型
    unsigned type:4;

    // 编码
    unsigned encoding:4;

    // 对象最后一次被访问的时间
    unsigned lru:REDIS_LRU_BITS; /* lru time (relative to server.lruclock) */

    // 引用计数
    int refcount;

    // 指向实际值的指针
    void *ptr;

} robj;
```

## 3. 字符串类型
redis使用一个sdshdr类型来存储字符串, 而redisObject的ptr字段执行该变量的地址.

```c++
/*
 * 保存字符串对象的结构
 */
struct sdshdr
{
    // buf 中已占用空间的长度
    int len;

    // buf 中剩余可用空间的长度
    int free;

    // 数据空间
    char buf[];
};
```
### 说明
* 存储键值所需要空间如何计算? 如*set key foobar*占用空间就是: *sizeof(redisObject) + sizeof(sdshdr) + strlen(foobar) = 30*;

* 如果键值可以使用64位有符号整型表示的时候, Redis将使用long类型来存储, 那么实际占用空间就是*sizeof(redisObject) = 16*, 例如 *set key 123456*;

* redis在启动后会预先建立10000个分别存储0到9999这些数字的redisObject类型对象作为共享对象; 如果设置的键值在这个范围内, 就直接引用这个共享对象而不是重新建立redisObject, 此时存储键值占用的空间为0字节;

* 当通过配置文件**maxmemory**设置了Redis最大空间大小时候, Redis不会使用共享内存, 因为每个键值都需要使用一个redisObject来记录其LRU信息;  

* Redis3.0 引入了**REDIS_ENCODING_EMBSTR**的字符串编码方式, 与**REDIS_ENCODING_RAW**编码类似, 也是基于sdshdr实现;

* 键值内容超过39字节时候, Redis使用**REDIS_ENCODING_EMBSTR**编码, 当对使用**REDIS_ENCODING_EMBSTR**编码的键值进行任何修改操作时候, 自动转换为**REDIS_ENCODING_RAW**编码;

### 总结
使用字符串类型存储对象ID这种小的数字是非常的节省存储空间, redis只需要一个存储键名和一个共享对象的引用即可;

## 4. 散列类型
散列表编码方式有两种: **REDIS_ENCODING_HT**和**REDIS_ENCODING_ZIPLIST**; 两种编码方式切换时机由配置文件中下面两项控制:

```c++
hash-max-ziplist-entries 512
hash-max-ziplist-value 64
```
当散列类型键的个数少于*hash-max-ziplist-entries*的值且每个字段名和字段值长度都小于*hash-max-ziplist-value*的值; 此时Redis会使用**REDIS_ENCODING_ZIPLIST**来存储该键;
否者就会使用**REDIS_ENCODING_HT**来存储, 转换过程透明;

### ZIPLIST编码方式
* 紧凑型编码方式; 牺牲部分读取性能以换取较高的空间利用率, 适合元素较少的时候;

#### 结构示意图:

![ziplist结构图](http://oaco4iuuu.bkt.clouddn.com/redis-ziplist.png)

说明:
1. zlbytes 表示整个结构占用的空间;
2. zltail 表示最后一个元素的偏移量; ztail可以是程序直接跳转到尾部而无需遍历, 执行尾部弹出等操作速度较快;
3. zllen 存储的是元素的数量, 类型为uint16_t;
4. zlen单字节表示, 标识结构的末尾, 值永远是255;
5. **REDIS_ENCODING_ZIPLIST**中每个元素由四部分组成如图所示;

### 总结
关于散列类型的空间优化, 主要是在两种编码方式的切换时机上; 从结构可以看出, 使用编码方式**REDIS_ENCODING_ZIPLIST**的时候, 做值的更新, 首先需要找到key, 然后删除, 然后更新, 删除和插入都是需要移动后面的元素的, 可见效率有多低;

所以, 建议不要讲配置中*hash-max-ziplist-entries*和*hash-max-ziplist-value*的值设置的过小;

## 5. 列表类型
列表类型内部编码方式为: **REDIS_ENCODING_LINKEDLIST** 和 **REDIS_ENCODING_ZIPLIST**; 两种编码方式切换时机由配置表中下面两个字段控制:

```c++

```
